# じゃんけんバトル - 認証システム全体フロー

## 概要

本システムは**Magic Link認証**を主軸とし、**パスワード認証**を非常口として提供する、現代的な認証システムです。
JWTトークンベースのセッション管理により、複数端末での同時ログインと細かい制御が可能です。

## 認証方式の組み合わせ

| 認証方式 | 用途 | 必須度 | 特徴 |
|---------|------|--------|------|
| Magic Link | メイン認証 | 必須 | パスワードレス、メールベース |
| JWT (Access + Refresh) | セッション管理 | 必須 | 短期+長期トークンの組み合わせ |
| パスワード認証 | 非常口 | 任意 | 従来方式、設定で有効化 |

---

## 1. Magic Link認証フロー

### 1.1 Magic Link発行（ログイン開始）

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant Frontend as フロントエンド
    participant API as APIサーバー
    participant DB as MySQL
    participant Email as メール送信

    User->>Frontend: メールアドレス入力
    Frontend->>API: POST /auth/magic-link {"email": "user@example.com"}
    
    API->>DB: メールの存在確認
    Note over API: 生トークン生成（32文字ランダム）
    Note over API: トークンハッシュ生成（SHA-256）
    
    API->>DB: INSERT magic_link_tokens<br/>(token_hash, email, expires_at)
    API->>Email: Magic Link送信<br/>URL: /auth/verify?token=生トークン
    API-->>Frontend: {"status": "sent", "expires_in": 900}
    Frontend-->>User: "メールを確認してください"
```

**データ保存例:**
```sql
-- magic_link_tokens テーブル
INSERT INTO magic_link_tokens (
    token_hash,    -- SHA-256(生トークン) 
    email,         -- "user@example.com"
    user_id,       -- 既存ユーザーの場合のみ
    issued_at,     -- 現在時刻
    expires_at,    -- 15分後
    ip_address,    -- リクエスト元IP
    user_agent     -- ブラウザ情報
);
```

### 1.2 Magic Link認証（ログイン完了）

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant Frontend as フロントエンド
    participant API as APIサーバー
    participant DB as MySQL
    participant Redis as Redis

    User->>Frontend: Magic Linkクリック
    Frontend->>API: GET /auth/verify?token=生トークン
    
    Note over API: 受信トークンをハッシュ化
    API->>DB: SELECT * FROM magic_link_tokens<br/>WHERE token_hash = ハッシュ値<br/>AND used_at IS NULL<br/>AND expires_at > NOW()
    
    alt トークンが有効
        API->>DB: UPDATE magic_link_tokens<br/>SET used_at = NOW()
        
        alt 新規ユーザー
            Note over API: user_id生成（例: user_123456）
            API->>DB: INSERT users (user_id, email)
            API->>DB: INSERT auth_credentials (user_id, is_password_enabled=FALSE)
        end
        
        Note over API: device_id生成（フロントエンドから受信）
        Note over API: session_id生成
        
        API->>DB: INSERT sessions<br/>(session_id, user_id, device_id)
        API->>DB: INSERT refresh_tokens<br/>(token_id, session_id, token_hash)
        
        Note over API: アクセスJWT生成（15分）
        Note over API: リフレッシュトークン生成（30日）
        
        API->>Redis: セッション情報キャッシュ<br/>SET session:session_id
        
        API-->>Frontend: {"access_token": "jwt...", "refresh_token": "token...", "user": {...}}
        Frontend-->>User: ログイン完了
    else トークンが無効
        API-->>Frontend: {"error": "invalid_token"}
        Frontend-->>User: "リンクが無効です"
    end
```

---

## 2. パスワード認証フロー

### 2.1 パスワード設定（初回 or 変更）

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant Frontend as フロントエンド
    participant API as APIサーバー
    participant DB as MySQL

    Note over User: 既にログイン済み（Magic Link等）
    User->>Frontend: 設定画面でパスワード入力
    Frontend->>API: POST /auth/password/set<br/>{"password": "secure123", "confirm": "secure123"}<br/>Header: Authorization: Bearer JWT

    API->>API: JWT検証（user_id取得）
    Note over API: パスワード強度チェック
    Note over API: Argon2idでハッシュ化
    
    API->>DB: UPDATE auth_credentials SET<br/>password_hash = ハッシュ値,<br/>password_algo = 'argon2id',<br/>password_version = 1,<br/>is_password_enabled = TRUE,<br/>password_updated_at = NOW()<br/>WHERE user_id = JWT.sub
    
    API->>DB: INSERT security_events<br/>(user_id, event_type='password_set')
    
    API-->>Frontend: {"status": "password_set"}
    Frontend-->>User: "パスワードが設定されました"
```

### 2.2 パスワードログイン

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant Frontend as フロントエンド
    participant API as APIサーバー
    participant DB as MySQL
    participant Redis as Redis

    User->>Frontend: メール・パスワード入力
    Frontend->>API: POST /auth/login<br/>{"email": "user@example.com", "password": "secure123", "device_id": "device_abc"}
    
    API->>DB: SELECT u.user_id, ac.password_hash, ac.password_algo<br/>FROM users u<br/>JOIN auth_credentials ac ON u.user_id = ac.user_id<br/>WHERE u.email = ? AND ac.is_password_enabled = TRUE
    
    alt ユーザー存在 & パスワード有効
        Note over API: Argon2id検証
        alt パスワード正解
            Note over API: session_id生成
            API->>DB: INSERT sessions<br/>(session_id, user_id, device_id)
            API->>DB: INSERT refresh_tokens<br/>(token_id, session_id, token_hash)
            
            Note over API: アクセスJWT生成（15分）
            API->>Redis: セッション情報キャッシュ
            API->>DB: INSERT security_events<br/>(user_id, event_type='login_success')
            
            API-->>Frontend: {"access_token": "jwt...", "refresh_token": "token...", "user": {...}}
            Frontend-->>User: ログイン完了
        else パスワード間違い
            API->>DB: INSERT security_events<br/>(user_id, event_type='login_failed')
            API-->>Frontend: {"error": "invalid_credentials"}
            Frontend-->>User: "認証に失敗しました"
        end
    else ユーザー不存在 or パスワード無効
        API-->>Frontend: {"error": "invalid_credentials"}
        Frontend-->>User: "認証に失敗しました"
    end
```

---

## 3. JWTトークン管理フロー

### 3.1 アクセストークン更新（リフレッシュ）

```mermaid
sequenceDiagram
    participant Frontend as フロントエンド
    participant API as APIサーバー
    participant DB as MySQL
    participant Redis as Redis

    Note over Frontend: アクセストークン期限切れ検知
    Frontend->>API: POST /auth/refresh<br/>{"refresh_token": "token...", "device_id": "device_abc"}
    
    Note over API: リフレッシュトークンをハッシュ化
    API->>DB: SELECT rt.token_id, rt.session_id, s.user_id<br/>FROM refresh_tokens rt<br/>JOIN sessions s ON rt.session_id = s.session_id<br/>WHERE rt.token_hash = ハッシュ値<br/>AND rt.is_revoked = FALSE<br/>AND rt.expires_at > NOW()<br/>AND s.is_revoked = FALSE
    
    alt リフレッシュトークンが有効
        Note over API: 新しいアクセスJWT生成（15分）
        Note over API: 新しいリフレッシュトークン生成（ローテーション）
        
        API->>DB: UPDATE refresh_tokens<br/>SET is_revoked = TRUE<br/>WHERE token_id = 旧token_id
        
        API->>DB: INSERT refresh_tokens<br/>(token_id=新ID, session_id, token_hash=新ハッシュ, rotated_from=旧token_id)
        
        API->>Redis: セッション情報更新
        API->>DB: UPDATE sessions SET last_seen_at = NOW()
        
        API-->>Frontend: {"access_token": "新jwt...", "refresh_token": "新token..."}
        Frontend->>Frontend: トークン保存・リクエスト再実行
    else リフレッシュトークンが無効
        API->>DB: DELETE FROM sessions WHERE session_id = ?
        API->>Redis: セッション情報削除
        API-->>Frontend: {"error": "session_expired"}
        Frontend-->>Frontend: ログイン画面へリダイレクト
    end
```

### 3.2 セッション強制終了

```mermaid
sequenceDiagram
    participant Admin as 管理者
    participant AdminAPI as 管理API
    participant DB as MySQL
    participant Redis as Redis
    participant UserApp as ユーザーアプリ

    Admin->>AdminAPI: POST /admin/sessions/revoke<br/>{"session_id": "session_xyz"}
    
    AdminAPI->>DB: UPDATE sessions<br/>SET is_revoked = TRUE<br/>WHERE session_id = ?
    
    AdminAPI->>DB: UPDATE refresh_tokens<br/>SET is_revoked = TRUE<br/>WHERE session_id = ?
    
    AdminAPI->>Redis: DEL session:session_xyz
    AdminAPI->>DB: INSERT security_events<br/>(event_type='session_revoked', detail='{"reason": "admin_action"}')
    
    AdminAPI-->>Admin: {"status": "revoked"}
    
    Note over UserApp: 次回API要求時
    UserApp->>API: GET /api/some-endpoint<br/>Header: Authorization: Bearer JWT
    API->>Redis: GET session:session_xyz
    Note over API: セッション無効を検知
    API-->>UserApp: {"error": "session_invalid"}
    UserApp-->>UserApp: 強制ログアウト
```

---

## 4. 複合認証シナリオ

### 4.1 Magic Link → パスワード設定の流れ

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant System as システム

    User->>System: 1. Magic Linkでログイン
    Note over System: users テーブルに新規作成<br/>auth_credentials.is_password_enabled = FALSE
    
    User->>System: 2. 設定画面を開く
    User->>System: 3. "パスワードを設定"選択
    User->>System: 4. パスワード入力・確認
    Note over System: auth_credentials.password_hash 設定<br/>is_password_enabled = TRUE
    
    User->>System: 5. 次回以降、Magic Link or パスワードでログイン可能
```

### 4.2 パスワードリセットの流れ

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant System as システム

    User->>System: 1. "パスワードを忘れた"クリック
    User->>System: 2. メールアドレス入力
    Note over System: Magic Linkトークン発行・送信<br/>(パスワードリセット用途として記録)
    
    User->>System: 3. Magic Linkクリック
    Note over System: トークン検証成功
    User->>System: 4. 新しいパスワード設定
    Note over System: auth_credentials.password_hash 更新<br/>security_events に 'password_reset' 記録
```

---

## 5. セキュリティ機能

### 5.1 ブルートフォース攻撃対策

```sql
-- 直近30分間の失敗試行をカウント
SELECT COUNT(*) as failed_attempts
FROM security_events 
WHERE event_type = 'login_failed' 
    AND ip_address = ?
    AND created_at > DATE_SUB(NOW(), INTERVAL 30 MINUTE);

-- 5回以上失敗している場合はアクセス拒否
-- Redisでレート制限も併用推奨
```

### 5.2 同時ログイン端末数制限

```sql
-- ユーザーのアクティブセッション数確認
SELECT COUNT(*) as active_sessions
FROM sessions 
WHERE user_id = ? 
    AND is_revoked = FALSE;

-- 上限（例：5台）を超える場合は最古のセッションを無効化
UPDATE sessions 
SET is_revoked = TRUE 
WHERE session_id IN (
    SELECT session_id FROM (
        SELECT session_id 
        FROM sessions 
        WHERE user_id = ? AND is_revoked = FALSE 
        ORDER BY last_seen_at ASC 
        LIMIT 1
    ) as oldest
);
```

### 5.3 JWTブラックリスト（即時失効）

```sql
-- 緊急時のJWT無効化
INSERT INTO jwt_blacklist (jti_hash, user_id, reason, expires_at)
VALUES (SHA2(?, 256), ?, 'security_incident', ?);

-- API要求時のJWT検証
SELECT 1 FROM jwt_blacklist 
WHERE jti_hash = SHA2(?, 256) 
    AND expires_at > NOW();
```

---

## 6. Redis活用パターン

### 6.1 セッションキャッシュ

```redis
# セッション情報のキャッシュ（TTL: アクセストークンと同期）
SET session:session_123 '{"user_id":"user_456","device_id":"device_abc","last_seen":"2024-01-01T12:00:00Z"}' EX 900

# WebSocket接続管理
SET websocket:user_456 '{"session_id":"session_123","socket_id":"socket_789"}' EX 3600
```

### 6.2 レート制限

```redis
# Magic Link送信制限（同一メールアドレス）
SET ratelimit:magiclink:user@example.com 1 EX 60  # 1分間に1回

# ログイン試行制限（IPアドレス）
INCR ratelimit:login:192.168.1.100 EX 1800  # 30分間で試行回数カウント
```

---

## 7. 運用・監視

### 7.1 定期クリーンアップ

```sql
-- 期限切れトークンの削除（日次実行）
DELETE FROM magic_link_tokens WHERE expires_at < DATE_SUB(NOW(), INTERVAL 1 DAY);
DELETE FROM refresh_tokens WHERE expires_at < NOW() AND is_revoked = TRUE;
DELETE FROM jwt_blacklist WHERE expires_at < NOW();

-- 古いセキュリティイベントの削除（月次実行）
DELETE FROM security_events WHERE created_at < DATE_SUB(NOW(), INTERVAL 6 MONTH);
```

### 7.2 監視対象メトリクス

- **アクティブセッション数**: `SELECT COUNT(*) FROM sessions WHERE is_revoked = FALSE`
- **Magic Link使用率**: `security_events`の`magic_link_used`イベント
- **パスワード設定率**: `auth_credentials`で`is_password_enabled = TRUE`の割合
- **異常ログイン**: 短時間での多地点ログイン、深夜帯のアクセス等

---

## 8. エラーハンドリング

| エラーケース | HTTPステータス | レスポンス | 対応 |
|-------------|---------------|------------|------|
| Magic Link期限切れ | 400 | `{"error": "token_expired"}` | 再送信を促す |
| セッション無効 | 401 | `{"error": "session_invalid"}` | 再ログインへ誘導 |
| リフレッシュトークン無効 | 401 | `{"error": "session_expired"}` | ログイン画面へ |
| パスワード強度不足 | 400 | `{"error": "weak_password"}` | 強化を要求 |
| レート制限 | 429 | `{"error": "rate_limited"}` | 待機時間を表示 |

この認証システムにより、ユーザビリティとセキュリティを両立した、拡張性の高い認証基盤が構築できます。
